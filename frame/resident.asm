.model tiny
.286
.code
org 100h
locals @@
;====================================================================
;                                 DEFINE
;====================================================================
PTR_VIDMEM      equ 0b800h   ; сегмент видео памяти 
PTR_CMD         equ 0080h    ; указатель на командную строк
CH_END_STR      equ 0024h    ; символ конца строки '$'
CH_NULL         equ 0030h    ; '0'
CH_7_HEX        equ 0037h    ; '7' in hex
CH_SPACE        equ 0020h    ; hex code of space
END_CODE        equ 4c00h    ; код завершения программы
HOT_KEY_START   equ 003Bh    ; scan code 'F1' to start
HOT_KEY_STOP    equ 003Ch    ; scan code 'F2' to stop


;====================================================================
;                          Stylizing my frame
;====================================================================
WINDOW_WIDTH    equ 160d      ; ширина окна DOS в байтах
CENTER_Y        equ 11d       ; смещение строк для центрирования рамки
CENTER_X        equ 140d      ; смещение столбцов для центрирования рамки
FRAME_COLOR     equ 04Eh      ; Цвет рамки: жёлтый текст на красном фоне (04h - красный фон, 0Eh - жёлтый текст)
TEXT_COLOR      equ 04Eh      ; Цвет текста
HEAD_COLOR      equ 04Eh      ; Цвет заголовка
MY_LENGTH       equ 11        ; длина рамки
MY_WIDTH        equ 15        ; ширина рамки
AMOUNT_REGS     equ 13        ; кол-во регистров
;--------------------------------------------------------------------------


Start:  
        ;1)  ;1) Save addr of intr 09 vector with 35H
        push 0
        pop es            ; ES = 0 => чтобы указать на начало таблицы векторов 
        mov ax, 3509h	  ; AH = 35H - команда для получения адреса обработчика прерывания 
                          ; AL = 09H - это номер прерывания (клавиатура)
        int 21h		  ; возвращает адрес обработчика в ES:BX
        mov Old09Offs, bx ; сохраняем смещение оригинального обработчика
        mov bx, es        
        mov Old09Seg, bx  ; сохраняем сегмент оригинального обработчика

        ;2) Save addr of intr 08 vector with 35H
        push 0
        pop es            ; ES = 0 => чтобы указать на начало таблицы векторов
        mov ax, 3508h	  ; AH = 35H - команда для получения адреса обработчика прерывания 
                          ; AL = 08h номер прерывания (таймер)
        int 21h		  ; returns intr vector addr to <es:bx>
        mov Old08Offs, bx ; сохраняет смещение оригинального обработчика в переменной Old08Offs
        mov bx, es        
        mov Old08Seg, bx  ; сохраняет сегмент оригинального обработчика в переменной Old09Seg

        ;3) Устанавливаем новый обработчик для прерывания 09h
        push ds           ; save ds - seg of data
        mov dx, offset IntOverride09 
        push cs 
        pop ds            ; ds = cs, 
        mov ax, 2509h     ; AH = 25h функция DOS для установки адреса обработчика прерывания, 
                          ; AL - 09h  номер прерывания (клавиатура)
        cli
        int 21h	          ; устанавливаем новый обработчик прерывания по адр <ds:dx>
        pop ds            ; восстанавливаем DS

        ;4) Устанавливаем новый обработчик для прерывания 08h
        push ds           ; save ds - seg of data
        mov dx, offset IntOverride08
        push cs 
        pop ds            ; ds = cs
        mov ax, 2508h     ; AH = 25h функция DOS для установки адреса обработчика прерывания, 
                          ; AL - 08h  номер прерывания (таймер).
        int 21h	          ; устанавливаем новый обработчик прерывания по адр <ds:dx>
        pop ds            ; восстанавливаем DS

        ;5) Завершаем программы с резидентным оставлением в памяти
        mov dx, cs:[offset EndOfProg] ; загружаем смещение конца программы (EndOfProg) в регистр DX
        shr dx, 4         ; битовый сдвиг влево на 4
        inc dx 		  ; dx++ 
        ; sizeof(prog)/16+1 = SIZE OF CODE IN 16 byte paragraphs
        mov ax, 3100h     ; AH = 31h функция DOS "Terminate and Stay Resident"
                          ; AL = 00h код возврата.
        sti               ; включаем прерывания
        int 21h           ; прога завершается, но остается резидентной 

;====================================================================
; IntOverride09()
; Перехватчик прерывания клавиатуры (IRQ1, INT 09h) для анализа горячих клавиш
; и управления глобальной переменной bool_flag_to_draw.
;--------------------------------------------------------------------
; Использует и изменяет:
;   - Регистры: AX, BX, CX, DX, CL, FLAGS
;   - Память: изменяет значение по адресу bool_flag_to_draw
;   - Порты: 60h (порт данных клавиатуры), 61h (порт управления клавиатурой), 
;            20h (порт контроллера прерываний)
; Возвращает: ничего
; Сохраняет регистры: AX, BX, CX, DX, BP, SP
; Локальные переменные: 0
;====================================================================
IntOverride09	proc
                nop
                nop
                nop

                ; Сохраняем регистры и устанавливаем BP
                push bp
                mov  bp, sp         ; bp = sp 
                push ax bx cx dx
                ;----------------------------------------------------
                
                ; Анализ скан-кода и установка логических переменных
                in  al, 60h            ; считываем скан-код последней нажатой клавиши
                cmp al, HOT_KEY_START  ; сравниваем с горячей клавишей (CTRL+A)
                jne @@end_if1          ; если это не горячая клавиша, переходим к метке @@end_if1

@@do_if1:
                ; Если горячая клавиша нажата, устанавливаем флаг bool_flag_to_draw в 1
                mov bx, cs:[offset bool_flag_to_draw]
                mov byte ptr [bx], 1   

                ; Завершение обработки прерывания вручную
                ; 1) Регистр управления клавиатурой - 61h
                ;   Сигнал контроллеру клавиатуры - запись в 61h старшего бита:
                ;   1 - заблокировать, 0 - разблокировать
                ;   Это нужно сделать перед iret!
                in al, 61h          ; читаем текущее состояние порта управления клавиатурой
                or al, 80h          ; устанавливаем старший бит, чтобы заблокировать клавиатуру
                out 61h, al         ; отправляем новое значение обратно в порт 61h
                and al, not 80h     ; сбрасываем старший бит в 0 (01111111b)
                out 61h, al         ; отправляем новое значение в порт 61h
                
                ; 2) Отправка сигнала контроллеру прерываний (в регистр 20h) 
                ;    о завершении обработки прерывания (End Of Interrupt, EOI) = 20h 
                mov al, 20h         ; загружаем в AL значение 20h
                out 20h, al         ; отправляем это значение в порт 20h

                ; Восстанавливаем регистры и завершаем обработку прерывания
                pop dx cx bx ax
                mov sp,bp 
                pop bp
                iret

@@end_if1:  
                ; Проверяем, была ли нажата горячая клавиша для остановки (CTRL+X)
                in  al, 60h           ; считываем скан-код последней нажатой клавиши
                cmp al, HOT_KEY_STOP  ; сравниваем с горячей клавишей (CTRL+X)
                jne @@else_if2        ; если это не горячая клавиша, переходим к метке @@else_if2

@@do_if2:
                ; Если горячая клавиша нажата, устанавливаем флаг bool_flag_to_draw в 0
                mov bx, cs:[offset bool_flag_to_draw]
                mov byte ptr [bx], 0

                ; Завершение обработки прерывания вручную
                ; 1) Регистр управления клавиатурой - 61h
                ;   Сигнал контроллеру клавиатуры - запись в 61h старшего бита:
                ;   1 - заблокировать, 0 - разблокировать
                ;   Это нужно сделать перед iret!
                in al, 61h          ; читаем текущее состояние порта управления клавиатурой
                or al, 80h          ; устанавливаем старший бит, чтобы заблокировать клавиатуру
                out 61h, al         ; отправляем новое значение обратно в порт 61h
                and al, not 80h     ; сбрасываем старший бит в 0 (01111111b)
                out 61h, al         ; отправляем новое значение в порт 61h

                ; 2) Отправка сигнала контроллеру прерываний (в регистр 20h) 
                ;    о завершении обработки прерывания (End Of Interrupt, EOI) = 20h 
                mov al, 20h         ; загружаем в AL значение 20h
                out 20h, al         ; отправляем это значение в порт 20h

                ; Восстанавливаем регистры и завершаем обработку прерывания
                pop dx cx bx ax
                mov sp,bp 
                pop bp
                iret

@@else_if2:
                ; Если горячая клавиша не нажата, передаём управление оригинальному обработчику прерывания
                pop dx cx bx ax
                mov sp,bp 
                pop bp
                ; Переход на оригинальный обработчик прерывания и его выполнение
                db 0eah ; JMP FAR
                Old09Offs dw 0
                Old09Seg  dw 0
@@end_if2: 
        ;----------------------------------------------------
IntOverride09   endp

;=====================================================================================================
; IntOverride08()
; Перехватчик прерывания таймера (IRQ0, INT 08h) для обработки горячих клавиш и отрисовки рамки с регистрами.
;-----------------------------------------------------------------------------------------------------
; Uses and modifies::
;   - Регистры: AX, BX, CX, DX, SI, DI, BP, SP, ES, DS, FLAGS
;   - Память: изменяет значение по адресу bool_flag_to_draw
;   - Порты: нет
; Returns: ничего
; Saves registers: AX, BX, CX, DX, SI, DI, BP, SP, ES, DS
; Local variables:
;   - [bp-2] - IP (Instruction Pointer) из стека прерывания
;   - [bp-4] - CS (Code Segment) из стека прерывания
;   - [bp-6] - Сохранённый SP (Stack Pointer)
;=====================================================================================================
IntOverride08	proc
                nop
                nop
                nop

                push bp
                mov  bp,    sp      ; устанавливаем BP равным SP для доступа к локальным переменным через BP
                sub  sp, 6          ; устанавливаем BP равным SP для доступа к локальным переменным через BP
                mov [bp-6], sp      ; save sp
                push bx
                
                ;----------------------------------------------------------
                ; Получить скан-код и, если это горячая клавиша, нарисовать рамку
                mov bx, [bp-6]       
                add bx, 14          ; bx + 14 
                mov [bp-6], bx       
                ;if(global_bool_var == 1) {<draw frame with regs>}
@@begin_if:    
                mov bx, cs:[offset bool_flag_to_draw] ; загружаем адрес глобальной переменной в BX
                cmp byte ptr [bx], 1 ; 
                pop bx     
                jne @@end_if         ; if bool_flag_to_draw != 1 -> end_if
@@do_if:
                ;take ip & cs from stack in intr
                push cx              ; save regs
                mov cx, [bp+4]       ; Загружаем значение IP из стека прерывания в CX
                mov [bp-2], cx       ; [bp-2] = ip
                mov cx, [bp+6]       ; загружаем значение CS из стека прерывания в CX
                mov [bp-4], cx       ; [bp-4] = cs
                pop cx

                push [bp-4]          ; сохраняем CS в стеке
                push [bp-2]          ; сохраняем IP в стеке
                push ss es ds
                push [bp-6]
                push [bp] 
                push di si dx cx bx ax 
                
                push cs         
                pop ds               ; нам нужно установить ds := cs из-за ds:[si] := cs:[si]

                push PTR_VIDMEM      
                pop es               ; es = videomem

                call print_frame     ; draw frame, ret: di - угла рамки

                add di, 4            ; сдвигаем DI на 4 позиции для выравнивания текста
                add di, WINDOW_WIDTH ; сдвигаем DI на ширину окна для перехода к следующей строке
                
                ; Теперь в стеке находятся 13 актуальных регистров, которые используются как аргументы !!!
                call draw_regs        ; отрисовываем регистры 
                pop ax bx cx dx si di ; восстанавливаем значение регистров 
                add sp, 4
                pop ds es ss
                pop [bp-2]
                pop [bp-4]
@@end_if:
                ;-------------------------------------------------

                mov sp,bp 
                pop bp
                ; Переход на оригинальный обработчик прерывания и его выполнение
                ; Машинный код команды JMP FAR 
                db 0eah ; JMP FAR (To Electronic arts) Command - EA

                Old08Offs dw 0  ; Old offset
                Old08Seg  dw 0  ; Old segment
                nop
                nop
                nop
IntOverride08   endp

;=====================================================================================================
; print_frame()
; Функция для отрисовки рамки на экране.
;-----------------------------------------------------------------------------------------------------
; Uses and modifies:
;   - Регистры: AX, BX, CX, DX, SI, DI, BP, SP, ES, FLAGS
;   - Память: использует данные из style_frame и say_my_frame
;   - Порты: нет
; Returns: DI - указатель на угол рамки
; Saves registers: AX, BX, CX, DX 
; Local variables:
;   - [bp-2] - временное хранение DI (начальная позиция)
;   - [bp-4] - временное хранение SI (указатель на стиль рамки)
;=====================================================================================================
print_frame	proc
                nop 
                nop
                nop
             
                push bp                   ; сохраняем  bp, bp = sp
                mov  bp, sp  
                sub  sp, 4                ; выделяем 4 байта для 2 локальных переменных  
                push ax bx cx dx si       ;save regs

                ;---------------------------------------------
                ;SI - указатель на стиль рамки
                ;DI - указатель на текущую ячейку видеопамяти
                ;BH - цвет, BL - символ
                ;AX, CX, DX - вспомогательные регистры
                ;---------------------------------------------

                ;1) Устанавливаем стиль
                xor si,si
                mov si, offset style_frame

                ;2) Цвет
                xor bx, bx                  ; bx = 0
                mov bh, FRAME_COLOR 

                ;3) Устанавливаем по центру (под прямым углом)
                xor dx, dx
                mov ax, WINDOW_WIDTH        ; загружаем в AX ширину окна
                mov dx, CENTER_Y            ; загружаем в DX координату Y центра экрана
                mul dx                      ;  AX * DX (WINDOW_WIDTH * CENTER_Y) 
                add ax, CENTER_X            ; добавляем координату X центра экрана
                mov di, ax                  ; сохраняем начальную позицию для отрисовки в DI

                ;4) Установка начальной позиции DI
                ; di = center - (length / 2 * 2) -160 * (width / 2)
                mov ax, MY_LENGTH   ; AX = length
                mov cl, 2           
                div cl                      ; делим AX на 2, чтобы вычислить половину длины

@@begin_if:    ;check if (di % 2 != 0) - need align 1 byte!
                cmp ah, 0           
                je @@end_if                 ; если есть остаток при делении на 2 то идем дальше  
@@do_if:
                dec di                      ; length : 2n+1 => di - 1 (для выравнивания) 
@@end_if:
                sub di, MY_LENGTH           ; length 
                mov ax, MY_WIDTH            ; width     
                mov cl, 2d                  
                div cl          
                xor ah, ah
                mov cx, WINDOW_WIDTH
                mul cx
                sub di, ax

                push di                     ; save begin for p.6)

                ;5)   Отрисовка рамки
                ;5.1) Отрисовка верхней части (заголовка)
                push di                     ; save cell to jmp to next line!
                mov bl, byte ptr [si]       ; загружаем символ стиля рамки в BL
                mov word ptr es:[di], bx    ; записываем символ и цвет в видео память 
                add di, 2                   ; перемещаемся на следующую позицию в видеопамяти 
                inc si                      ; переходим к следую символу стиля 
                ;Заголовок рамки
                mov bh, HEAD_COLOR          ; цвет заголовка  
                mov al, CH_END_STR          ; загружаем символ конца строки в AL
                push si                     ; сохраняем si
                mov si, offset say_my_frame ; загружаем заголовок рамки в SI

@@while_loop:   ; while(*ptr != END_CHAR){write}
                cmp al, byte ptr [si]
                je @@while_end

                movsb                       ; копируем символ из SI в DI.     
                mov byte ptr es:[di], bh    ; устанавливаем цвет символа 
                inc di                      ; переходим на следующую позицию 

                inc cx                      
                inc dx
                jmp @@while_loop            ; пока не встретим символ конца строки 
@@while_end:
                pop si                      
                mov bh, FRAME_COLOR         ; возвращаем цвет рамки
                inc si
                mov bl, byte ptr [si]       ; загружаем символ стиля рамки в BL
                mov word ptr es:[di], bx    ; записываем символ и цвет в видеопамять
                add di, 2                   
                inc si
                ;восстановим di и jmp до следующей строки
                pop di
                add di, WINDOW_WIDTH        ; переходим на следующую строку
                ;----------------------------
                        
                xor cx,cx                   ; for (i = 2; i < width;i++){draw_line}
                add cx, 2                   ; из-за границ
@@for_loop: 
                cmp cx, MY_WIDTH            ; width
                jae @@for_end

                push MY_LENGTH              ; передаём длину рамки в стек как аргумент для draw_line
                call draw_line

                inc cx
                jmp @@for_loop              ; пока cx не будет равна ширине рамки 
@@for_end:
                add si, 3
                push MY_LENGTH              ; передаём длину рамки в стек как аргумент для draw_line
                call draw_line               
                add si, 3                   ; переходим к следующему символу стиля 

                pop di 
                ;--------------------------

                pop si dx cx bx ax          ; восстанавливаем регистры 
                mov sp,bp 	            ; sp = bp, восстанавливаем bp
                pop bp
                ret
print_frame 	endp
;=====================================================================================================
; draw_line(length)
; Функция для отрисовки горизонтальной линии рамки.
;-----------------------------------------------------------------------------------------------------
; Uses and modifies:
;   - Регистры: BX, CX, DI, SI, BP, SP, ES, FLAGS
;   - Память: использует данные из style_frame (через SI)
;   - Порты: нет
; Return: ничего
; Saves registers: CX, SI, BP, SP
; Local variables: 0
;=====================================================================================================
draw_line       proc
                nop
                nop
                nop

                push bp     
                mov  bp, sp                 ; BP = SP для доступа к аргументам функции через BP.
                push cx  si

                ;-------------------------------------------
                push di                     ; сохраняем, чтобы после отрисовки линий вернуться 
                                            ; к начальной позиции и перейти на следующую строку
                ;первый символ
                mov bl, byte ptr [si]       ; загружаем первый символ в BL
                mov word ptr es:[di], bx    ; загружаем символ и цвет в видео памяти 
                add di, 2                   ; переходим к следующей позиции видео памяти 
                inc si                      ; переходим к следующему символу стиля

                
                xor cx,cx                   ; for (i = 2; i < length;i++) {...}
                add cx, 2                   ; из-за границ
@@for_loop:
                cmp cx, [bp+4]              ; сравниваем CX с длиной линии (аргумент функции, переданный через стек)
                jae @@for_end               ; if CX >= [bp+4] -> for_end
                        
                mov bl, byte ptr [si]       
                mov word ptr es:[di], bx    ; записываем символ и цвет в видеопамять
                add di, 2                   ; перемещаем DI на следующую позицию в видеопамяти

                inc cx                      
                jmp @@for_loop              ; повторяем цикл 
@@for_end:
                ;последний символ 
                inc si                      ; следующий символ стиля
                mov bl, byte ptr [si]       ; загружаем следующий символ стиля рамки в BL 
                mov word ptr es:[di], bx    ; записываем символ и цвет в видеопамять
                add di, 2                   ; перемещаем DI на следующую позицию в видеопамяти

                ;восстанавливаем di и jmp до следующей строки
                pop di
                add di, WINDOW_WIDTH
                ;-------------------------------------------
                ; close action
                pop si cx   
                mov sp,bp
                pop bp
                ret 2                       ; завершаем функцию и возвращаем управление, удаляя 2 байта из стека (аргумент функции length).
draw_line endp
;=====================================================================================================
; draw_regs()
; Функция для отрисовки названий регистров и их значений в видеопамяти.
;-----------------------------------------------------------------------------------------------------
; Uses and modifies:
;   - Регистры: AX, BX, CX, DX, SI, DI, BP, SP, ES, FLAGS
;   - Память: использует данные из name_of_regs и значения регистров, переданные через стек
;   - Порты: нет
; Returns: ничего
; Saves registers: AX, BX, CX, DX, SI, DI, BP, SP
; Local variables:
;   - [bp-2] - счётчик для цикла (количество отрисованных регистров)
;=====================================================================================================
draw_regs       proc 
                nop
                nop
                nop

                push bp     
                mov  bp, sp                 ; bp = sp  
                sub  sp, 2                  ; выделяем 2 байта для 1 локальной переменной
                push ax bx cx dx di si      

                ;1) Устанавливаем цвет текста 
                xor dx, dx
                mov dh, TEXT_COLOR          ; загружаем в DH цвет текста 

                push di                     ; сохраняем для п.3)
                        
                ;2) Отрисовка названий регистров
                mov si, offset name_of_regs ; загружаем в SI адрес строки с названиями регистров
                mov [bp-2], word ptr 0d     ;  [bp-2] = 0 (счётчик) 

@@for_loop1:    ;for([bp-2]; [bp-2]< N_REGS; [bp-2]++) {for...}
                cmp [bp-2], word ptr AMOUNT_REGS ; сравниваем счетчик с количеством 
                jae @@for_end1              ; if [bp-2] = AMOUNT_REGS -> for_end1

                push di                     ;save start
                xor cx,cx                   ;for(cx = 0; cx < 2; cx++){draw 1 symbol}
@@for_loop:
                cmp cx, 2                   ; cx ? 2
                jae @@for_end               ; if cx >=2 -> for_end
                        
                movsb                       ; копируем символ из DS:[SI] в ES:[DI] и увеличиваем SI и DI
                mov byte ptr es:[di], dh    ; устанавливаем цвет символа
                inc di          

                inc cx
                jmp @@for_loop              ; повторяем внутренний цикл 
@@for_end: 
                mov dl, CH_SPACE            ; загружаем в DL символ пробела
                mov word ptr es:[di], dx    ; записываем пробел и цвет в видеопамять
                add di, 2                   ; перемещаем DI на следующую позицию

                pop di                      
                add di, WINDOW_WIDTH        ; переходим на следующую строку в видеопамяти

                inc word ptr [bp-2]         ; [bp-2] + 1 (счетчик регистров)
                jmp @@for_loop1             ; повторяем внешний цикл 
@@for_end1:            
                ;3)Отрисовка значений регистров
                pop di  
                        
                push bp 
                mov cx, AMOUNT_REGS        ; загружаем в CX количество регистров

@@for_loop2:    ;for(cx = AMOUNT OF REGS; cx > 0; cx++) {...}
                push di          
                add di, 12                 ; перемещаем DI на позицию последней цифры значения регистра

                push [bp+4]                ; push [bp];bp += 2
                call draw_hex_word  
                add bp,2

                pop di                     ; восстанавливаем и устанавливаем следующую строчку из п.2)
                add di, WINDOW_WIDTH       ; переходим на следующую строку в видеопамяти
                loop @@for_loop2           ; пока CX = 0 
                pop bp
                ;---------------------------------

                pop si di dx cx bx ax
                mov sp,bp 
                pop bp
                ret     
draw_regs endp

;=====================================================================================================
; draw_hex_word(number)
; Функция для отрисовки 16-битного числа в шестнадцатеричном формате в видеопамяти.
;-----------------------------------------------------------------------------------------------------
; Uses and modifies:
;   - Регистры: AX, BX, CX, DX, DI, SI, BP, SP, ES, FLAGS
;   - Память: использует видеопамять (через ES:DI)
;   - Порты: нет
; Returns: ничего
; Saves registers: AX, BX, CX, DI, SI, BP, SP
; Local variables: 0
;=====================================================================================================
draw_hex_word   proc
                nop
                nop
                nop

                push bp     
                mov  bp, sp                 ; SP = BP
                push ax bx cx di si

                ;---------------------------------------------------------------------------
                ; Преобразование шестнадцатеричного числа в строку
                ; DX := остаток от деления (AX mod 16), AX := частное от деления (AX div 16)
                ; DX = 0, AX = [bp+4] - число
                ; Деление на 16 -> результат: цифра в шестнадцатеричном формате
                ;---------------------------------------------------------------------------

                mov cx,4                    ; устанавливаем CX = 4 (количество цифр в 16-битном шестнадцатеричном числе)
                mov ax, [bp+4]              ; загружаем в AX число, переданное в функцию через стек.
@@for_1:            
                xor dx,dx
                mov bx, 16d
                div bx                      ; AX / BX (результат сохр в AX, остаток в DX)

                
@@begin_if:     ;Преобразование цифры в символ (DX — цифра)
                cmp dl, 9                   ; сравниваем остаток с 9 
                ja @@do_else

@@do_if:
                add dl, CH_NULL             ;'0' + digit = '0-9'
                jmp @@end_if                ; if DX > 9 -> end_if

@@do_else:  
                add dl, CH_7_HEX            ; '7' + digit = 'A-F'

@@end_if:
                ;Отрисовка цифры в видеопамяти
                mov dh, TEXT_COLOR          ; загружаем в DH цвет текста
                mov word ptr es:[di], dx    ; записываем символ и цвет в видеопамять
                sub di, 2                   ; перемещаем DI на предыдущую позицию в видеопамяти (так как цифры записываются справа налево).
                loop @@for_1

                ;---------------------------------
                ;close action
                pop si di cx bx ax
                mov sp,bp ; close action
                pop bp
                ret 2                       ; завершаем функцию и возвращаем управление, удаляя 2 байта из стека (аргумент функции number)
draw_hex_word   endp
;=====================================================================================================
;                                    CONSTANTS
;=====================================================================================================
bool_flag_to_draw db 0  

style_frame     db 0c9h, 0cdh, 0bbh, 0bah, 020h, 0bah, 0c8h, 0cdh, 0bch                         ; строка стиля рамки
name_of_regs    db 'ax', 'bx', 'cx', 'dx', 'si', 'di', 'bp', 'sp', 'ds', 'es', 'ss', 'cs', 'ip' ; названия регистров
say_my_frame    db 'REGISTERS', CH_END_STR  ;REGISTERS
;-----------------------------------------------------------------------
EndOfProg:
end		Start